<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>DeckExplorer</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <h1>DeckExplorer</h1>

  <h2>components/DeckExplorer.js</h2>

  <h3>generateItemCombos 関数</h3>
  <pre><code><span class="comment">// function: JavaScriptの関数定義に使うキーワード。</span>
<span class="comment">// generateItemCombos: 関数名。アイテムの組み合わせを生成する目的の関数。</span>
<span class="comment">// (currentItems, candidates): 引数リスト。currentItems は現在装備中のアイテム配列、candidates は候補アイテムの配列。</span>
function generateItemCombos(currentItems, candidates) {

    <span class="comment">// const: 再代入不可な変数（定数）を宣言するキーワード。</span>
    <span class="comment">// fixed: currentItems内で最初に null でない（実際に装備されている）アイテムを1つ取得して変数に格納。</span>
    <span class="comment">// .find(): 配列の中から条件に一致する最初の要素を返す。</span>
    const fixed = currentItems.find((id) => id !== null);

    <span class="comment">// slotCount: currentItems の中から null を除いた要素の数をカウント。</span>
    <span class="comment">// .filter(): 条件に一致する要素だけを抽出して新しい配列を返す。</span>
    <span class="comment">// .length: 配列の長さ（要素数）を取得。</span>
    const slotCount = currentItems.filter((id) => id !== null).length;

    <span class="comment">// usable: 使用可能なアイテム群（候補＋装備中だが固定ではないもの）から重複と null を除いた配列。</span>
    <span class="comment">// currentItems.filter(id => id !== fixed): 固定アイテムと同じIDを除外。</span>
    <span class="comment">// [...a, ...b]: スプレッド構文で配列を展開・結合。</span>
    <span class="comment">// .filter(id => id !== null): nullを除去。</span>
    <span class="comment">// new Set(...): 重複要素を排除した集合に変換。</span>
    <span class="comment">// Array.from(...): Setを再び配列に変換。</span>
    const usable = Array.from(
        new Set([
        ...currentItems.filter((id) => id !== fixed),
        ...candidates
        ].filter((id) => id !== null))
    );

    <span class="comment">// results: 最終的に返す組み合わせリストを格納する空の配列を初期化。</span>
    const results = [];

    <span class="comment">// count: usableの数またはスロット数-1の小さい方までループ（fixedを除いた分）。</span>
    <span class="comment">// for: ループ構文。条件を満たす限り繰り返し処理を実行。</span>
    for (let count = 0; count <= Math.min(usable.length, slotCount - 1); count++) {

        <span class="comment">// pick: 内部関数。再帰的にusableからアイテムを選んで組み合わせを構築。</span>
        <span class="comment">// current: 現在選ばれているアイテムの配列。</span>
        <span class="comment">// start: どの位置から選び始めるか（前回より後ろのみ選ぶことで重複を防止）。</span>
        const pick = (current, start = 0) => {

        <span class="comment">// current.length === count: 指定数のアイテムが選ばれたら結果に追加。</span>
        <span class="comment">// [fixed, ...current]: 固定アイテムを先頭に付加した配列。</span>
        if (current.length === count) {
            results.push([fixed, ...current]);
            return;
        }

        <span class="comment">// start以降の要素から順に再帰的に選択していく。</span>
        for (let i = start; i < usable.length; i++) {
            pick([...current, usable[i]], i + 1);
        }
        };

        <span class="comment">// 最初は空の選択リストから再帰を開始。</span>
        pick([]);
    }

<span class="comment">// return: 関数の戻り値を指定するキーワード。</span>
<span class="comment">// results: fixed + usableアイテムの組み合わせ配列を返す。</span>
return results;
}
    </code></pre>

    <h3>useState による状態管理</h3>
<pre><code><span class="comment">// シミュレーション戦略の状態を保持する変数。</span>
<span class="comment">// 初期値は "HeuristicStrategy"（経験則ベースの戦略）を指定。</span>
<span class="comment">// プルダウンメニューで変更され、simulate関数に渡される。</span>
const [strategy, setStrategy] = useState("HeuristicStrategy");

<span class="comment">// シミュレーション実行後のデータを格納する状態変数。</span>
<span class="comment">// simulate関数の結果オブジェクトがここに格納され、表示や他の処理に利用される。</span>
<span class="comment">// 初期値は null（未実行）で、runSimulationの最後にsetされる。</span>
const [simulatorData, setSimulatorData] = useState(null);

<span class="comment">// ユーザーが選択可能なアイテム候補3枠を保持する状態。</span>
<span class="comment">// 初期値は [null, null, null] で、未選択状態を意味する。</span>
<span class="comment">// UI上で StagePItems コンポーネントと連動して、選択に応じて更新される。</span>
const [itemCandidates, setItemCandidates] = useState([null, null, null]);

<span class="comment">// シミュレーションが実行中かどうかを示す状態。</span>
<span class="comment">// true の間は「シミュレーション中」UI（例：Loader）が表示され、ボタン操作も無効化される。</span>
<span class="comment">// runSimulation関数内で true → false に切り替わる。</span>
const [running, setRunning] = useState(false);

<span class="comment">// 実行結果の中から上位のアイテム組み合わせ（スコア順）を格納。</span>
<span class="comment">// runSimulation 関数内でスコア順にソートされ、slice(0, 5) で上位5組のみ抽出して格納される。</span>
<span class="comment">// UIでは comboScore や EntityIcon に使われる。</span>
const [topCombos, setTopCombos] = useState([]);

<span class="comment">// 保存されたデッキ構成（loadout）を一時的に保持するための状態。</span>
<span class="comment">// 現状ではこの状態自体は明示的に使用されていないが、拡張用として定義されている可能性がある。</span>
const [savedLoadout, setSavedLoadout] = useState(null);

<span class="comment">// 複数の Web Worker を保持するための参照（useRef は再レンダリングを引き起こさない）。</span>
<span class="comment">// useEffect で生成され、runSimulation 中には直接参照されないが、ワーカー終了処理などに使われる。</span>
const workersRef = useRef();
</code></pre>

    <h3>useMemo による設定生成</h3>
<pre><code><span class="comment">// useMemo: 値の再計算を最適化するReactフック。</span>
<span class="comment">// loadout または stage に変更があった時のみ、新しい IdolStageConfig を再生成する。</span>
const config = useMemo(() => {
    <span class="comment">// IdolConfig: 現在のloadout（装備やスキルなど）からアイドルの構成情報を生成。</span>
    const idolConfig = new IdolConfig(loadout);

    <span class="comment">// StageConfig: 現在選択されているステージの条件（ボーナスなど）を設定。</span>
    const stageConfig = new StageConfig(stage);

    <span class="comment">// IdolStageConfig: アイドル構成とステージ構成を合わせた最終的な実行用設定。</span>
    return new IdolStageConfig(idolConfig, stageConfig);

<span class="comment">// 第二引数: 依存配列。loadoutまたはstageが変更された時だけ関数を再実行。</span>
}, [loadout, stage]);
    </code></pre>

    <h3>アイテム・スキルカードのインディケーション取得</h3>
    <pre><code><span class="comment">// getIndications: 指定された構成（config, loadout）に基づき、アイテムやスキルカードの効果を示す「指標」を取得。</span>
<span class="comment">// 指標（indication）は、UIで色や数値によって強調表示するために使われる。</span>
<span class="comment">// 返り値は2つのプロパティを持つオブジェクト：pItemIndications, skillCardIndicationGroups。</span>
const { pItemIndications, skillCardIndicationGroups } = getIndications(
    config,   <span class="comment">// シミュレーション対象の設定（アイドル・ステージ構成）</span>
    loadout   <span class="comment">// 現在のユーザーの装備構成（アイテム・スキルカードなど）</span>
    );
    </code></pre>

    <h3>useEffect による Web Worker の初期化処理</h3>
    <pre><code><span class="comment">// useEffect: React の副作用フック。</span>
<span class="comment">// この関数は DeckExplorer コンポーネントが初めて画面に表示されるときに実行され、</span>
<span class="comment">// Web Worker を初期化し、シミュレーションを並列処理できるようにする。</span>
useEffect(() => {
    <span class="comment">// numWorkers: 使用する Web Worker の数。初期値は 1 に設定。</span>
    let numWorkers = 1;

    <span class="comment">// navigator.hardwareConcurrency が使用可能な場合、</span>
    <span class="comment">// それを上限 MAX_WORKERS と比較して、より効率的な並列数を決定する。</span>
    if (navigator.hardwareConcurrency) {
        numWorkers = Math.min(navigator.hardwareConcurrency, MAX_WORKERS);
    }

    <span class="comment">// workersRef.current を空の配列として初期化。</span>
    <span class="comment">// ここに複数の Worker インスタンスを格納していく。</span>
    workersRef.current = [];

    <span class="comment">// numWorkers の数だけループして Web Worker を作成。</span>
    <span class="comment">// worker.js は実際のシミュレーション計算をバックグラウンドで実行するスクリプト。</span>
    <span class="comment">// new URL(..., import.meta.url) によって相対パスから正しいURLが生成される。</span>
    for (let i = 0; i < numWorkers; i++) {
        workersRef.current.push(
        new Worker(new URL("../../simulator/worker.js", import.meta.url))
        );
    }

    <span class="comment">// クリーンアップ関数: このコンポーネントがアンマウント（削除）される時に実行される。</span>
    <span class="comment">// メモリリークを防ぐため、作成したすべての Worker を terminate() で停止する。</span>
    return () => workersRef.current?.forEach((worker) => worker.terminate());

<span class="comment">// 第二引数 [] により、この useEffect は初回マウント時に一度だけ実行される。</span>
}, []);
    </code></pre>

    <h3>replaceItemCandidate 関数</h3>
    <pre><code><span class="comment">// replaceItemCandidate: 指定された位置のアイテム候補を差し替える関数。</span>
<span class="comment">// UI 上で候補アイテムを選択／変更したときに呼び出される。</span>
<span class="comment">// index: どの候補スロットを置き換えるか（0〜2）。</span>
<span class="comment">// id: 新しく選択されたアイテムの ID（null の可能性もあり）。</span>
function replaceItemCandidate(index, id) {
    <span class="comment">// itemCandidates は useState で管理されているので、</span>
    <span class="comment">// 直接変更せずにスプレッド構文でコピーを作る。</span>
    const updated = [...itemCandidates];

    <span class="comment">// 指定された index の位置に新しい id を格納。</span>
    updated[index] = id;

<span class="comment">// 状態を更新（React によって再描画が発生）。</span>
setItemCandidates(updated);
}
    </code></pre>

    <h3>runSimulation 関数 - シミュレーション準備と組み合わせ生成</h3>
    <pre><code><span class="comment">// runSimulation: 「シミュレート」ボタンを押したときに実行されるメイン関数。</span>
<span class="comment">// ユーザーの loadout と itemCandidates を使って組み合わせを生成・評価し、上位5件を UI に表示する。</span>
async function runSimulation() {
    <span class="comment">// 実行中フラグを true にして、UI 上でボタンなどを無効化。</span>
    setRunning(true);

    <span class="comment">// 実行時間計測の開始（開発者コンソール向け）。</span>
    console.time("simulation");

    <span class="comment">// loadout.pItemIds（現在装備中）と itemCandidates（候補）から組み合わせを生成。</span>
    <span class="comment">// generateItemCombos 関数により、fixed アイテム + 候補の全パターン（最大スロット数まで）を列挙。</span>
    <span class="comment">// slice(0, 20) により上位20個の組み合わせに限定（パフォーマンス向上のため）。</span>
    const combos = generateItemCombos(loadout.pItemIds, itemCandidates).slice(0, 20);

    <span class="comment">// 結果を格納する配列。後でスコア順にソートして使う。</span>
    const scored = [];
    </code></pre>

    <h3>runSimulation 関数（中盤）- 構成の変換とスコア計算</h3>
    <pre><code><span class="comment">// combos 配列内の各組み合わせに対してループ処理を行う。</span>
for (const combo of combos) {
    <span class="comment">// 現在の loadout に combo（アイテム組み合わせ）を適用して新しい loadout を作成。</span>
    const newLoadout = { ...loadout, pItemIds: combo };

    <span class="comment">// 新しい loadout を使ってシミュレーション設定（config）を再構成。</span>
    const newConfig = new IdolStageConfig(
        new IdolConfig(newLoadout),
        new StageConfig(stage)
    );

    <span class="comment">// simulate 関数を実行して、与えられた設定と戦略に基づきスコア結果を取得。</span>
    const result = simulate(newConfig, strategy, DE_NUM_RUNS);

    <span class="comment">// スコアの平均を算出（合計を回数で割る）。</span>
    const avg = result.scores.reduce((sum, v) => sum + v, 0) / result.scores.length;

    <span class="comment">// スコアと組み合わせをセットで scored に追加。</span>
    scored.push({ result, combo, avg });

<span class="comment">// UI フリーズを防ぐため、1ループごとに短い休止（非同期待機）。</span>
await new Promise((r) => setTimeout(r, 0));
}
    </code></pre>

    <h3>runSimulation 関数（後半）- 上位選定と状態更新</h3>
    <pre><code><span class="comment">// scored 配列をスコア（avg）の降順に並び替え。</span>
<span class="comment">// 高スコア順に上から並べることで、最適な組み合わせを簡単に抽出できる。</span>
scored.sort((a, b) => b.avg - a.avg);

<span class="comment">// 最もスコアが高かったシミュレーション結果を simulatorData に格納。</span>
<span class="comment">// UI上で詳細情報を表示するために使用される。</span>
setSimulatorData(scored[0].result);

<span class="comment">// 上位5件の組み合わせを抽出して state に保存。</span>
<span class="comment">// アイコンとスコアを UI に表示する。</span>
setTopCombos(scored.slice(0, 5));

<span class="comment">// 実行中フラグを false にして UI を再度操作可能に戻す。</span>
setRunning(false);

<span class="comment">// 実行時間の計測終了。console.time との対で開発者向けの情報提供。</span>
console.timeEnd("simulation");
}
    </code></pre>

    <h3>saveCurrentLoadout 関数 - 現在のデッキ構成をローカル保存</h3>
    <pre><code><span class="comment">// saveCurrentLoadout: 現在の loadout（装備構成）を localStorage に保存する関数。</span>
<span class="comment">// ボタン操作により呼び出され、デッキを一時的にブラウザ内に記録できる。</span>
function saveCurrentLoadout() {
    <span class="comment">// 保存する構成オブジェクトを作成。</span>
    <span class="comment">// skillCardIdGroups や customizationGroups が未定義の場合、空配列を補完しておく。</span>
    const saved = {
        ...loadout,
        skillCardIdGroups: loadout.skillCardIdGroups || [],
        customizationGroups: loadout.customizationGroups || [],
    };

    <span class="comment">// JSON.stringify で文字列化し、キー 'deckExplorerSavedLoadout' で localStorage に保存。</span>
    localStorage.setItem("deckExplorerSavedLoadout", JSON.stringify(saved));

<span class="comment">// 保存完了後にユーザーへ通知。</span>
alert("ローカルに保存しました。");
}
    </code></pre>

    <h3>loadSavedLoadout 関数 - 保存された構成の復元</h3>
    <pre><code><span class="comment">// loadSavedLoadout: localStorage に保存されたデッキ構成を読み込む関数。</span>
<span class="comment">// 「読込」ボタンを押したときに実行され、保存済み構成を現在の状態に適用する。</span>
function loadSavedLoadout() {
    <span class="comment">// localStorage から保存データを取得。存在しない場合はアラートを表示して終了。</span>
    const data = localStorage.getItem("deckExplorerSavedLoadout");
    if (!data) return alert("保存されたデッキが見つかりません。");

    try {
        <span class="comment">// 文字列データを JSON としてパースして JavaScript オブジェクトに変換。</span>
        const saved = JSON.parse(data);

        <span class="comment">// パースに成功した場合、現在の loadout に反映する。</span>
        setLoadout(saved);

        <span class="comment">// ユーザーに復元成功を通知。</span>
        alert("デッキを復元しました。");
    } catch (err) {
        <span class="comment">// パースに失敗（例：不正な JSON）の場合、エラーメッセージを表示。</span>
        console.error("Load error:", err);
        alert("読み込みに失敗しました。");
    }
}
    </code></pre>
    
  <a href="../index.html">← 目次に戻る</a>
</body>
</html>
